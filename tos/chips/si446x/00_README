This is the driver for the Silcon Labs si446x family of chips.  In
particular the si4468.  Should also work with the si4463.

The h/w interface consists of a SPI port and the following signals
CTS (clear to send, GPIO1 default configuration), IRQN (radio interrupts),
SDN (shutdown), and CSN (chip select, aka NSEL).

We use h/w CTS instead of using bus cycles.  This allows monitoring CTS
on power up as well as when sending commands to the radio chip.  Using
a h/w CTS for the handshake is just cleaner.

    si446x_irqn                 si446x_sclk
    si446x_cts                  si446x_miso
    si446x_csn  (aka nsel)      si446x_mosi
    si446x_sdn


States:

  (hw states:)
                TX      RX
    Shutdown    15ms    15ms            Full powerdown 30nA, no registers
    Standby     440us   440us           40 nA, good regs, no WUT
    Sleep       440us   440us           740 nA, good regs, WUT, 32kHz
    SPI_Active  340us   340us           1.35 mA
    Ready       100us   100us           1.8 mA
    TX          -       100us           18 mA @ +10dBm
    RX          100us   75us            10.9 mA or 13.7 mA

    TX Tune     58us    -               7.8 mA
    RX Tune     -       60us            7.6 mA

  (sw states:)

    SDN:        h/w is in shutdown state
    POR_WAIT:   h/w taken out of shutdown, waiting for the POR to complete.
    PWR_UP_WAIT:POR has completed, POWER_UP has been issued.  Waiting for
                h/w to finish.
    LOAD:       Loading configuration.


API notes:

- documentation implies that one can use either the h/w (gp1) cts or the
  s/w CTS (via CMD_READ_CMD_BUF) to obtain the value of CTS.  But they
  don't actually appear to be exactly the same.  (See notes on POWER_UP
  for at least one incongruence).

  CTS = h/w CTS pin,  CTS(sw) = s/w CTS via CMD_READ_CMD_BUF.


- POWER_UP:

  CTS 1, bring NSEL down (cs)
  CTS 1, write POWER_UP
  CTS 0, write parameters
  CTS 0, write last parameter, NSEL up (no cs)
  CTS 0, wait....   16mS

  check cts .should be 1.  (no?  panic)

Prior to Power_Up, no NIRQ (high):

  int_status:
    int_pend = 0x00, chip_pend = 0x00
  chip_status:
    chip_pend = 0x0x8

  we clear it, then read again...  Doesn't clear.  Strange.
  We then power_up and look again.

On Power_Up, we see NIRQ go low.  We see the following:

  int_status:
    int_pend = 0x4, int_status = 0x4,
        (says chip_pend interrupt)
    ph_pend = 0x0, ph_status = 0x2,
    modem_pend = 0x0, modem_status = 0x0,
    chip_pend = 0x14, chip_status = 0x14,
        (14 says State_change, chip_rdy)
    info_flags = 0x0

  chip_status:
    chip_pend = 0x14, chip_status = 0x14,
    cmd_err_status = 0x00, cmd_err_cmd_id = 0x0,
    info_flags = 0x0

- PART_INFO

  (rsp[1] << 8) | rsp[2] is part number, ie. 4468.  from RadioHead
  RH_RF24.cpp code.



Packet format:

The si446x chips has many configuration options that determine what the
actual packet format looks like.  These fields must be programmed properly
on both ends of the communications channel for communications to occur.


The SI443X radio driver has the following configuration options. Some of 
these are set in the platforms/xxx/chips/si443x/RadioConfig.h header file, 
others can be set in your Makefile.

SI443X_DEF_RFPOWER:

This is the default value of the TX POWER register. This can be changed via the
PacketTransmitPower interface provided by the SI443XActiveMessageC.

SI443X_BASE_FREQ_10MHZ:
SI443X_BASE_FREQ_KHZ:
SI443X_BASE_FREQ_MILLIHZ:

The base carrier frequency is set according to these two values. The carrier frequency is
set to (SI443X_BASE_FREQ_10MHZ * 10^7 + SI443X_BASE_FREQ_KHZ * 10^3 + SI443X_BASE_FREQ_MILLIHZ * 10^(-2) ) Hz.
Any values between 240000 kHz (240.000 MHz) and 959999 kHz (959.999 Mhz) can be given. For details, see the RadioConfig.h file.

SI443X_CHANNEL_STEP_KHZ:

This is the spacing between channels over the frequency band. The 0th channel starts
from the preset base carrier frequency, the k'th channel starts from (base carrier frequency) +
k * SI443X_CHANNEL_STEP_KHZ. The channel spacing is defined in kHz precision, minimum 
value is 1 (1 kHz), maximum value is 2550 (2,55 Mhz).

SI443X_MODEM_CONFIG:

The modem is configured based on precomputed register values. These values can be found in RadioConfig.h, new config values should be
inserted there. If multiple modem configuration exist, there is a possibility to choose from them using this constant.

SI443X_DEF_CHANNEL:

This is the default value of the Frequency Hopping Channel Select register
This can be cahanged via the RadioChannel interface provided by the 
SI443XActiveMessageC.

SI443X_BACKOFF_MIN
SI443X_BACKOFF_INIT
SI443X_BACKOFF_CONG

The minimum backoff time, the initial backoff time, and the cognestion backoff
time in microseconds for the random CSMA/CA algorithm. See the SI443XRadioP.nc.



*** getting properties

  If you ask for more than 16 consecutive, it will return zeros.


*** Radio Dump Notes:

  takes about 5ms.


*** Anomalies

  On the way up, after Power_Up, we drf() (A), clear interrupts, then drf() (B) again.

  After A, we see rd.gpio_cfg.nirq is 0x27 as it should be.  After B, it is 0xA7, why is
  the high order bit set?   Becasue nirq is set and the read returns the value of NIRQ
  as the high order bit (NIRQ_STATE).  so yes 0x27 becomes 0xa7.  If NIRQ were down then
  this would be 0x27.


*** Power Up State:

  4463: power up state

  part_info    = {chiprev = 0x11, part_15 = 0x44, part_7 = 0x63, pbuild = 0x0, id_15 = 0x0, id_7 = 0xf, customer = 0x0, romid = 0x3},
  func_info    = {revext = 0x3, revbranch = 0x0, revint = 0xf, reserved0 = 0x0, reserved1 = 0x0, func = 0x1},
  gpio_cfg     = {gpio0 = 0xc, gpio1 = 0x8, gpio2 = 0xc, gpio3 = 0xc, nirq = 0x27, sdo = 0xb, gen_config = 0x0},
  rxfifocnt    = 0x0, txfifofree = 0x40,
  int_status   = {int_pend = 0x4, int_status = 0x4, ph_pend = 0x0, ph_status = 0x2, modem_pend = 0x0,
                  modem_status = 0x0, chip_pend = 0x14, chip_status = 0x14, info_flags = 0x0},
  ph_status    = {ph_pend = 0x0, ph_status = 0x2},
  modem_status = {modem_pend = 0x0, modem_status = 0x0, curr_rssi = 0x0, latch_rssi = 0x0, ant1_rssi = 0x0,
                  ant2_rssi = 0x0, afc_freq_offset15 = 0x82, afc_freq_offset7 = 0xfe, info_flags = 0x0},
  chip_status  = {chip_pend = 0x14, chip_status = 0x14, cmd_err_status = 0x0, cmd_err_cmd_id = 0x0, info_flags = 0x0}
  device_state = 0x3, channel = 0x0,
  frr_a = 0x4, frr_b = 0x4, frr_c = 0x3, frr_d = 0x0,
  packet_info_len = { 0x00, 0x00 },

  properties:  (* doesn't match default listed in silabs doc)
* gr00_global   = {0x0 <repeats 11 times>},
  gr01_int      = {0x4, 0x0, 0x0, 0x4},
  gr02_frr      = {0x1, 0x2, 0x9, 0x0},  (int_status), (int_pending), (current_state), (disabled)
  gr10_preamble = {0x8, 0x14, 0x0, 0xf, 0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
* gr11_sync     = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
  gr12_pkt      = {0x0, 0x1, 0x8, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30, 0x30, 0x0, 0x0, 0x0, 0x0},
  gr20_modem    = {0x2, 0x80, 0x7, 0xf, 0x42, 0x40, 0x1, 0xc9, 0xc3, 0x80, 0x0, 0x6, 0xd3, 0x0, 0x0,
                   0x67, 0x60, 0x4d, 0x36, 0x21, 0x11, 0x8, 0x3, 0x1, 0x1, 0x0, 0x8, 0x3, 0xc0, 0x0,
                   0x10, 0x20, 0x0, 0x0, 0x0, 0x4b, 0x6, 0xd3, 0xa0, 0x6, 0xd3, 0x2, 0xc0, 0x0, 0x0,
                   0x23, 0x83, 0x69, 0x0, 0x40, 0xa0, 0x0, 0x0, 0xe0, 0x0, 0x0, 0x11, 0x10, 0x10,
                   0xb, 0x1c, 0x40, 0x0, 0x0, 0x2b, 0xc, 0xa4, 0x3, 0x56, 0x2, 0x0, 0xa3, 0x2, 0x80,
                   0xff, 0xc, 0x1, 0x0, 0x32, 0x3, 0x0 <repeats 16 times>},
  gr21_modem    = {0xff, 0xba, 0xf, 0x51, 0xcf, 0xa9, 0xc9, 0xfc, 0x1b, 0x1e, 0xf, 0x1, 0xfc, 0xfd,
                   0x15, 0xff, 0x0, 0xf, 0xff, 0xc4, 0x30, 0x7f, 0xf5, 0xb5, 0xb8, 0xde, 0x5, 0x17,
                   0x16, 0xc, 0x3, 0x0, 0x15, 0xff, 0x0, 0x0},
* gr22_pa       = {0x8, 0x7f, 0x0, 0x5d, 0x00, 0x23, 0x00},
* gr22_pa       = {0x8, 0x7f, 0x0, 0x5d, 0x80, 0x23, 0x03},
  gr23_synth    = {0x2c, 0xe, 0xb, 0x4, 0xc, 0x73, 0x3, 0x5},
  gr30_match    = {0x0 <repeats 12 times>},
  gr40_freq_ctl = {0x3c, 0x8, 0x0, 0x0, 0x0, 0x0, 0x20, 0xff},
  gr50_hop      = {0x4, 0x1, 0x0, 0x1},
  grF0_pti      = {0x0, 0x0, 0x0, 0x0, 0x0}   (4463 doesn't have a PTI)


*** Various Command completion times:

    Time in uS after command has been issued and we start looking for CTS back up.

    In general it looks like most commands take between 24 and 25us for CTS to come
    back up.

    Commands that we've looked at include part_info, func_info, gpio_cfg_nc, fifo_info_nc,
    ph_status_nc, modem_status_nc, chip_status_nc, int_status_nc.

    Device_State and Packet_Info_Nc appear to take 0uS.  At end of the sequence in
    Dump_Radio_Full (drf).


*** Interrupts

    get_int_status:

    get_modem_status:

    get_ph_status:

    get_chip_status:




s/w vs h/w cts: h/w cts is the way to go, here is why.  s/w cts accesses the SPI bus via READ_CMD_BUFF
to get CTS.  This takes around 24 uS.  h/w cts read the status of cts on gpio1 (as programmed).  This
takes 1 uS.  Command timings get reduced approximately 20%.  h/w cts is simpler, more straight forward,
faster for commands, and probably more reliable.


command timings (drf):  (h/w cts)
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 1, t_cts0 = 1, t_cmd0 = 17, d_len0 = 1, t_cts_r = 6, t_reply = 110, d_reply_len = 10, t_elapsed = 147},
{cmd = 2, t_cts0 = 1, t_cmd0 = 82, d_len0 = 7, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0}<repeats 13 times>,
{cmd = 16, t_cts0 = 1, t_cmd0 = 17, d_len0 = 1, t_cts_r = 8, t_reply = 89, d_reply_len = 8, t_elapsed = 127},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 19, t_cts0 = 1, t_cmd0 = 93, d_len0 = 8, t_cts_r = 24, t_reply = 99, d_reply_len = 9, t_elapsed = 230},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 21, t_cts0 = 1, t_cmd0 = 28, d_len0 = 2, t_cts_r = 8, t_reply = 46, d_reply_len = 4, t_elapsed = 96},
{cmd = 22, t_cts0 = 1, t_cmd0 = 17, d_len0 = 1, t_cts_r = 6, t_reply = 47, d_reply_len = 4, t_elapsed = 84},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0},
{cmd = 32, t_cts0 = 1, t_cmd0 = 50, d_len0 = 4, t_cts_r = 28, t_reply = 120, d_reply_len = 11, t_elapsed = 211},
{cmd = 33, t_cts0 = 1, t_cmd0 = 28, d_len0 = 2, t_cts_r = 21, t_reply = 47, d_reply_len = 4, t_elapsed = 108},
{cmd = 34, t_cts0 = 1, t_cmd0 = 28, d_len0 = 2, t_cts_r = 26, t_reply = 120, d_reply_len = 11, t_elapsed = 187},
{cmd = 35, t_cts0 = 2, t_cmd0 = 27, d_len0 = 2, t_cts_r = 21, t_reply = 78, d_reply_len = 7, t_elapsed = 140},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0} <repeats 15 times>,
{cmd = 51, t_cts0 = 1, t_cmd0 = 17, d_len0 = 1, t_cts_r = 3, t_reply = 47, d_reply_len = 4, t_elapsed = 80},
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0}<repeats 203 times>,
{cmd = 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 38, t_reply = 78, d_reply_len = 7, t_elapsed = 0}

property timings (drf):
{grp: 0, t_cts0 = 1, t_cmd0 = 40, d_len0 = 4, t_cts_r = 26, t_reply = 141, d_reply_len = 13, t_elapsed = 236},
{grp: 1, t_cts0 = 1, t_cmd0 = 40, d_len0 = 4, t_cts_r = 16, t_reply = 67, d_reply_len = 6, t_elapsed = 152},
{grp: 2, t_cts0 = 1, t_cmd0 = 40, d_len0 = 4, t_cts_r = 13, t_reply = 68, d_reply_len = 6, t_elapsed = 150},
{grp: 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0}<repeats 13 times>,
{grp: 16, t_cts0 = 1, t_cmd0 = 40, d_len0 = 4, t_cts_r = 22, t_reply = 173, d_reply_len = 16, t_elapsed = 264},
{grp: 17, t_cts0 = 1, t_cmd0 = 40, d_len0 = 4, t_cts_r = 29, t_reply = 130, d_reply_len = 12, t_elapsed = 229},
{grp: 18, t_cts0 = 2, t_cmd0 = 80, d_len0 = 8, t_cts_r = 42, t_reply = 231, d_reply_len = 21, t_elapsed = 395},
{grp: 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0} <repeats 13 times>,
{grp: 32, t_cts0 = 6, t_cmd0 = 240, d_len0 = 24, t_cts_r = 160, t_reply = 1161, d_reply_len = 108, t_elapsed = 1660},
{grp: 33, t_cts0 = 3, t_cmd0 = 120, d_len0 = 12, t_cts_r = 75, t_reply = 455, d_reply_len = 42, t_elapsed = 707},
{grp: 34, t_cts0 = 1, t_cmd0 = 40, d_len0 = 4, t_cts_r = 24, t_reply = 99, d_reply_len = 9, t_elapsed = 192},
{grp: 35, t_cts0 = 1, t_cmd0 = 40, d_len0 = 4, t_cts_r = 24, t_reply = 110, d_reply_len = 10, t_elapsed = 203},
{grp: 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0}<repeats 12 times>,
{grp: 48, t_cts0 = 1, t_cmd0 = 40, d_len0 = 4, t_cts_r = 27, t_reply = 152, d_reply_len = 14, t_elapsed = 248},
{grp: 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0} <repeats 15 times>,
{grp: 64, t_cts0 = 1, t_cmd0 = 40, d_len0 = 4, t_cts_r = 27, t_reply = 110, d_reply_len = 10, t_elapsed = 206},
{grp: 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0} <repeats 15 times>,
{grp: 80, t_cts0 = 1, t_cmd0 = 40, d_len0 = 4, t_cts_r = 27, t_reply = 68, d_reply_len = 6, t_elapsed = 164},
{grp: 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0} <repeats 159 times>,
{grp: 240, t_cts0 = 1, t_cmd0 = 40, d_len0 = 4, t_cts_r = 38, t_reply = 78, d_reply_len = 7, t_elapsed = 185},
{grp: 0, t_cts0 = 0, t_cmd0 = 0, d_len0 = 0, t_cts_r = 0, t_reply = 0, d_reply_len = 0, t_elapsed = 0} <repeats 15 times>


Initial state after power up:  (before frr mod)

